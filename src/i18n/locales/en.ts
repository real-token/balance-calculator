export default {
  tasks: {
    getBalancesREG: {
      noJsonFiles: "No JSON files found in the outDatas directory",
      availableFiles: "JSON files available:",
      processingTimestamp: "INFO: Processing for timestamp {{timestamp}}, {{date}}",
      numberOfHolders: "Info: number of holders: {{count}}",
      numberOfHoldersTemporaryFile: "Number of holders loaded from the temporary file:",
      urlGraphQL: "INFO: URL GraphQL",
      askUseMock: "Use mock test data?",
      askDexsNetwork: "For which networks will we extract the DEX and wallet balances?",
      askDexs: "Do you want to extract the balances for the DEXs?",
      askDexsForNetwork: "For the network {{network}}, for which DEXs do you want to extract the balances?",
      askUrlGraphQL: "What URL GraphQL to use for the network {{network}}?",
      askCalculationType: "For a multi-day range, do you want a sum or an average of balances?",
      calculationTypeSum: "Total sum of balances",
      calculationTypeAverage: "Daily average of balances",
      askTargetAddress: "Which address would you like to analyze (all or 0x address)?",
      errorInvalidAddress: "Please enter a valid 0x address or 'all'",
    },
    calculatePowerVoting: {
      noJsonFiles: "No JSON files found in the outDatas directory",
      invalidVotingPower: "Invalid voting power value for address {{address}}: {{value}}",
      askModel: "Which input model do you want to use?",
      infoModelAutoDetected: "Input model detected automatically: {{model}}",
      askPowerVotingModel: "Which power voting calculation model do you want to use?",
      askDataBalancesRegSnapshotJsonFile: "Which snapshot file contains the REG balance data? (balancesREG......json)",
      askPreviousDataPowerVotingJsonFile:
        "Which JSON file contains the previously used voting power data to update the voting power?  (powerVotingREG......json)",
      askBatchSize: "What batch size do you want to use for the on-chain transaction?",
      messageBatchSizeError: "The batch size must be an integer!",
      warnPowerVotingValue: "Invalid voting power value for address {{address}}: {{value}}",
      warnPowerVotingTraitment: "Error processing voting power for address {{address}}: {{error}}",
    },
    classementREG: {
      noJsonFiles: "No JSON files found in the outDatas directory, please first execute the GetBalancesREG task",
      infoJsonFileAvailable: "JSON files available:",
      messageEchec: "Please enter a positive integer or 'all'.",
      askTopN: "How many top holders do you want to display (all or number)?",
      askUseBalance: "Which balance would you like to use for the ranking?",
      noBalanceKeysFound: "No balance keys found in the JSON file. Please check the data format.",
    },
    getAddressOwnRealToken: {
      askDateRange: "Start and end dates:",
      currentTimestamp: "Processing timestamp:",
      infoNumberOfHolders: "Number of unique holders:",
    },
  },
  common: {
    errors: {
      apiKeyMissing: "The API key for {{service}} is not defined in the .env file",
      notGenerated: "Unhandled error",
      promiseRejection: "Unhandled promise rejection:",
      warnTaskNotImplemented: "The task {{task}} is not yet implemented.",
    },
    infos: {
      infoJsonFileGenerated: "JSON file created at location: \n",
      infoCsvFileGenerated: "CSV file created at location: \n",
      infoFileNotFound: "File not found: {{filePath}}",
    },
    ask: {
      askTask: "Which task do you want to execute?",
      askUseTempFile: "Do you want to use a temporary file to resume?",
    },
  },
  utils: {
    graphql: {
      askUrlGraphQL: "What URL GraphQL to use for the network {{network}}?",
      infoDexProcessing: "The DEX {{dex}} on {{network}} is being processed",
      warnNoFunctionForDex: "WARNING: No function found to retrieve balances for the DEX {{dex}}",
      timeQuery: "Query for {{dex}} on {{network}}",
      errorDexOrNetworkNotFound:
        "Error: DEX or NETWORK not found or not implemented : DEX->{{dex}} on {{network}} network",
      infoQueryStart: "Info: DÃ©but de client.request(query)",
      infoQueryEnd: "Info: Fin de client.request(query)",
      infoQueryMockData: "Info: MAJ_MOCK_DATA",
      errorQueryFailed: "The query failed after 3 attempts:",
      errorGraphNotSync:
        "The graph is out of sync. The graph has indexed up to block number {{indexedBlockNumber}}, but the data for block number {{requestedBlockNumber}} is not yet available, there is a difference of {{difference}} blocks.\n\nCheck the indexing before continuing.",
      askRetry: "Do you want to retry a series of attempts?",
      errorQueryFailedAfterRetry: "The query failed, there are {{retries}} attempts left, pause of {{delayTime}}s:",
    },
    inquirer: {
      askTokenAddresses: "Which tokens do you want to use?",
      askDateRange: "Enter the start date UTC (format YYYY-MM-DD):",
      askDateRangeEnd: "Enter the end date UTC (format YYYY-MM-DD):",
      askSnapshotTime: "Enter the snapshot timestamp (format HH:MM:SS):",
      askContinue: "Do you want to continue?",
      askMessageValidateRange: "Please enter a valid UTC date in the format YYYY-MM-DD",
      askMessageValidateTime: "Please enter a valid UTC time in the format HH:MM:SS",
      askUseTempFile: "Which file do you want to use?",
      askMessageValidateCheckbox: "Please select at least one option.",
      askCustomUrl: "What is the custom URL?",
      askMessageValidateCustomUrl: "Please enter a valid URL (http://... or https://...)",
    },
    lib: {
      infoAskBlockNumber: "Enter the block number (format integer):",
      errorApiUrlNotFound: `No API URL found for the network "{{network}}"`,
      errorApiKeyNotFound: `The API key for the network "{{network}}" is not defined or incorrect ({{apiKey}})`,
      errorApiRequestFailed: `The request failed after 3 attempts, pause of {{delayTime}}s:`,
      errorApiRequestFailedAfterRetry: `The request ({{apiUrl}}) failed "{{attempt}}" times, retry in {{delayTime}} seconds...`,
      errorGetBlockNumberFromTimestamp: `All attempts to get the block number from a timestamp failed`,
      errorKeyFactory: `Unrecognized case option: "{{caseOption}}"`,
      errorTokenNotFoundInPool: `Token not found in the pool: {{token}}`,
      errorTokenNotMatchPool: `Tokens do not match the pool: {{fromToken}} and {{toToken}}`,
    },
    queryDexs: {
      infoUseMockData: "Info: Using mock data for {{dex}}",
      infoDexOrNetworkNotFound: "INFO: Missing configuration for the network {{network}}",
      infoQueryStart: "\nInfo: Starting the request {{dex}} on {{network}}",
      infoQueryEnd: "Info: End of the request {{dex}} on {{network}}",
      errorNoFunctionForDex: `WARNING: No retrieval function found for the DEX {{dex}}`,
      errorQueryFailed: "The request failed after several attempts:",
      errorCalculateTokenEquivalent: "Error calculating the equivalent {{token}} in REG:",
      warnFileNotFound: `WARNING: getRegBalances{{dexName}} -> dexConfigs.mockData "{{mockData}}", the corresponding file does not exist.`,
      infoGetRegBalances: `INFO: getRegBalances{{dexName}} -> dexConfigs is undefined for "{{network}}"`,
      errorQueryNotFound: `Query "{{operationName}}" not found in the GraphQL document`,
      errorQueryPool: `An error occurred during the 3 attempts of pool_query queries: {{pool_id}}:`,
      errorPoolNotFound: `the pools {{pool_id}} were not found`,
      errorQueryPosition: `An error occurred during the 3 attempts of position_query queries for the pools: {{pool_id}}:`,
      infoQueryPosition: `the pools {{pool_id}} have no open positions`,
      warnPoolNoPosition: `the pool {{pool_id}} has no open positions`,
      infoTickToPrice: `\nINFO: current price={{price}} pool {{pool_id}} {{token1}} for {{token0}} fee {{feeTier}}% at tick {{tick}}`,
      infoInOutRange: `{{isActive}} : {{owner}} position {{id}} in the interval [{{tick_lower}},{{tick_upper}}]: {{adjusted_amount1}} {{token1}} and {{adjusted_amount0}} {{token0}} at the current price`,
      infoInactivePosition: `Total (including inactive positions): {{total_amount0}} {{token0}} and {{total_amount1}} {{token1}}`,
      infoTotalLiquidity: `Total liquidity of active positions: {{active_positions_liquidity}} (must be equal to {{poolLiquidity}})`,
    },
  },
  models: {
    normalize: {
      infoNormalizer: "INFO: Normalization of data with model {{model}}",
      infoApplyModifier: "INFO: Application of the modifier {{modifier}}",
      infoNoOptions: "No options passed to the normalizer, apply the default normalization",
    },
  },
  modifiers: {
    infoApplyModifier: "Start of {{modifier}}",
  },
};
